# Working with projects

If you're working on a very small script or program that fits into
one module and has no external dependencies (i.e. you aren't importing libraries that
aren't part of the Haskell base language), you can get along very well
using the interpreter `ghci` to run and experiment with the code and the
compiler `ghc` to build an executable. For anything bigger you need a
*build tool*. This will automate downloading of the dependencies, make sure everything is compiled in the
right order, make it easy to run a suite of tests and to package your
application for other users. There are two main ways of building
Haskell projects -- [`stack`](https://docs.haskellstack.org/en/stable/README/) and [`cabal`](https://www.haskell.org/cabal/). I tend to use `cabal` so that's what is
described below.

`cabal` is installed on Linux in the labs but it will be an older version that needs to be upgraded. Start by entering these commands into a terminal:

```bash
$ cabal update

$ cabal install cabal-install
```

This will download the latest list of packages from the "Hackage"
repository (which is where haskell developers upload libraries and
other software for distribution) and install the latest version of
`cabal`. The default location for packages is
`~/.cabal/bin`, where `~` is your home directory,
e.g. `/home/ab123`. So to run programs installed by `cabal` (such as the
new version of it you just installed), you need to
add this location to your `PATH` variable. This is a Linux environment
variable containing a list of locations in the file system that Bash
will look in when you type a command in to a
terminal. You can check the current state of `PATH` like this:

```bash
$ echo $PATH
```

You can add the `cabal` bin (short for "binary") directory to PATH by editing the file `~/.bashrc`.  Add these lines to the bottom of the file:

```bash
PATH=~/.cabal/bin:$PATH
export PATH
```

Then apply the changes:

```bash
$ source .bashrc
```

Check that the changes were applied by echoing `PATH` again. The new
version of `cabal` should now be the first one that the system
encounters when you enter the command. Check this using the `which`
command, which reports the location of executables in your `PATH`. You
should see something like this:

```bash
$ which cabal
/home/ab123/.cabal/bin/cabal
```

Now you can start using `cabal` to build your haskell projects. The
basic idea is that each project lives in its own directory and if the
project is called `myproject` there should a file called `myproject.cabal`
at the top level. You can generate it using `cabal` like this:

```bash
$ mkdir myproject
$ cd myproject
$ cabal init
```

Any project consists of either an *executable* (a runnable program) or a
*library* (code that other developers will import to their own projects)
or both. An executable needs to have an entry point, which is a module
called `Main.hs` which includes a function called `main` with the right
type. For example:

```haskell
-- In module Main.hs
module Main where

main :: IO ()
main = print "Hello World!"
```

The norm is to put the code in a directory called `src`
and the tests in a directory called `tests`, so the structure might look
something like this:

```
myproject/
  - src/
    Main.hs
  - tests/
    MyTestSuite.hs 
  myproject.cabal 
``` 
  
There will probably also be some other files generated by `cabal` that
you don't need to worry about. You need to tell `cabal` about the
structure of your project, where the files are and so on. The cabal file 
contains a "stanza" (a named block of config
details) for each executable, library and test-suite. To get an idea of
how this works, take a look at [config
file](https://github.com/jimburton/MkPasswd/blob/master/mkPasswd.cabal)
for the `MkPasswd` project, which is about as simple as it gets, and compare it to the [project
structure](https://github.com/jimburton/MkPasswd). Given the the names of the stanzas in the config file, 
we build and run it like this:

```bash
$ cabal configure
$ cabal install
$ cabal run mkPasswd
$ cabal run test-mkPasswd
```
